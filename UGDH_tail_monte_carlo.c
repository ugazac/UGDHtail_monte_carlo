#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>
#include<getopt.h>
#include<time.h>
#include <sys/time.h>
#include<limits.h>

#define MAXLEN 9000

typedef struct Atom{
 double x,y,z;
 char name[5];
 double charge;
 double vdw;
 int ek;
 int chi;
 int typ;
} atom;

typedef struct Amino{
 struct Atom side_chain[60];
 struct Atom next_one[5];
 int main_chain[10];
 char name[5];
 int ac_num;
 char chain;
 int num_side;
 int curr_rot;
 double curr_ener;
 int neigh_list[50];
 //int allowed_rot[30];
} amino;

char amino_acids[][4] = {"ALA","ARG","ASN","ASP","CYS","GLN","GLU","GLY","HIS","ILE","LEU","LYS","MET","PHE","PRO","SER","THR","TRP","TYR","VAL","XXX","XXX","XXX","XXX","XXX","XXX","XXX","XXX","XXX","XXX"};
char amino_single[] = "ARNDCQEGHILKMFPSTWYV";
int max_side[] = {1,28,9,8,3,15,15,1,8,5,4,19,13,5,1,3,3,7,5,3};
int max_rot[] = {0,4,1,1,0,2,2,0,1,1,1,3,2,1,0,1,1,1,1,0};
//struct Amino amino_database[30][30];
double ncac_angles[MAXLEN][20];
double calc_angles[MAXLEN][20];
struct Amino *peptide, *tmppept, *framepept, *smallpept;
struct Amino **amino_database;

char randoms(int *randf, int min, int max)
{
    int retries= 10;
    unsigned long long rand64;

    while(retries--) {
        if ( __builtin_ia32_rdrand64_step(&rand64) ) {
            //*randf= (int) rand64%(max-min) + min;
            *randf = (rand64 % (max + 1 - min)) + min;
            return 1;
        }
    }
    return 0;
}

double checkphivals[] = {-155.0,-155.0,-155.0,-155.0,-155.0,-155.0,-155.0,-155.0,-155.0,-155.0,-145.0,-145.0,-145.0,-145.0,-145.0,-145.0,-145.0,-145.0,-145.0,-145.0,-135.0,-135.0,-135.0,-135.0,-135.0,-135.0,-135.0,-135.0,-135.0,-135.0,-125.0,-125.0,-125.0,-125.0,-125.0,-125.0,-125.0,-125.0,-125.0,-125.0,-115.0,-115.0,-115.0,-115.0,-115.0,-115.0,-115.0,-115.0,-115.0,-115.0,-105.0,-105.0,-105.0,-105.0,-105.0,-105.0,-105.0,-105.0,-105.0,-105.0,-95.0,-95.0,-95.0,-95.0,-95.0,-95.0,-95.0,-95.0,-95.0,-95.0,-85.0,-85.0,-85.0,-85.0,-85.0,-85.0,-85.0,-85.0,-85.0,-85.0,-75.0,-75.0,-75.0,-75.0,-75.0,-75.0,-75.0,-75.0,-75.0,-75.0,-65.0,-65.0,-65.0,-65.0,-65.0,-65.0,-65.0,-65.0,-65.0,-65.0,-55.0,-55.0,-55.0,-55.0,-55.0,-55.0,-55.0,-55.0,-55.0,-55.0,-125.0,-125.0,-125.0,-115.0,-115.0,-115.0,-105.0,-105.0,-105.0,-95.0,-95.0,-95.0,-85.0,-85.0,-85.0,-75.0,-75.0,-75.0,-65.0,-65.0,-65.0,-55.0,-55.0,-55.0,-155.0,-155.0,-145.0,-145.0,-135.0,-135.0,-125.0,-125.0,40.0,40.0,40.0,40.0,40.0,40.0,40.0,40.0,50.0,50.0,50.0,50.0,50.0,50.0,50.0,50.0,60.0,60.0,60.0,60.0,60.0,60.0,60.0,60.0};
double checkpsivals[] = {90.0,100.0,110.0,120.0,130.0,140.0,150.0,160.0,170.0,180.0,90.0,100.0,110.0,120.0,130.0,140.0,150.0,160.0,170.0,180.0,90.0,100.0,110.0,120.0,130.0,140.0,150.0,160.0,170.0,180.0,90.0,100.0,110.0,120.0,130.0,140.0,150.0,160.0,170.0,180.0,90.0,100.0,110.0,120.0,130.0,140.0,150.0,160.0,170.0,180.0,90.0,100.0,110.0,120.0,130.0,140.0,150.0,160.0,170.0,180.0,90.0,100.0,110.0,120.0,130.0,140.0,150.0,160.0,170.0,180.0,90.0,100.0,110.0,120.0,130.0,140.0,150.0,160.0,170.0,180.0,90.0,100.0,110.0,120.0,130.0,140.0,150.0,160.0,170.0,180.0,90.0,100.0,110.0,120.0,130.0,140.0,150.0,160.0,170.0,180.0,90.0,100.0,110.0,120.0,130.0,140.0,150.0,160.0,170.0,180.0,-65.0,-55.0,-45.0,-65.0,-55.0,-45.0,-65.0,-55.0,-45.0,-65.0,-55.0,-45.0,-65.0,-55.0,-45.0,-65.0,-55.0,-45.0,-65.0,-55.0,-45.0,-65.0,-55.0,-45.0,-65.0,-55.0,-65.0,-55.0,-65.0,-55.0,-65.0,-55.0,15.0,25.0,35.0,45.0,55.0,65.0,75.0,85.0,15.0,25.0,35.0,45.0,55.0,65.0,75.0,85.0,15.0,25.0,35.0,45.0,55.0,65.0,75.0,85.0};

double rama_limits[5][5] = {{3.0,2.7,2.8,2.2,3.5},{2.7,2.7,2.6,2.2,3.5},{2.8,2.6,2.6,2.2,3.5},{2.2,2.2,2.2,1.9,2.2},{3.5,3.5,3.5,2.4,3.5}};


double sigma[39][39] = {{0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.190644,0.289858,0.279214,0.292148,0.286917,0.297286,0.300125,0.000000,0.258133,0.190644,0.000000,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.317218,0.317218,0.322877,0.319359,0.327277,0.356662,0.348067,0.348067,},
{0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.190644,0.289858,0.279214,0.292148,0.286917,0.297286,0.300125,0.000000,0.258133,0.190644,0.000000,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.317218,0.317218,0.322877,0.319359,0.327277,0.356662,0.348067,0.348067,},
{0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.190644,0.289858,0.279214,0.292148,0.286917,0.297286,0.300125,0.000000,0.258133,0.190644,0.000000,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.317218,0.317218,0.322877,0.319359,0.327277,0.356662,0.348067,0.348067,},
{0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.190644,0.289858,0.279214,0.292148,0.286917,0.297286,0.300125,0.000000,0.258133,0.190644,0.000000,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.317218,0.317218,0.322877,0.319359,0.327277,0.356662,0.348067,0.348067,},
{0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.190644,0.289858,0.279214,0.292148,0.286917,0.297286,0.300125,0.000000,0.258133,0.190644,0.000000,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.317218,0.317218,0.322877,0.319359,0.327277,0.356662,0.348067,0.348067,},
{0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.190644,0.289858,0.279214,0.292148,0.286917,0.297286,0.300125,0.000000,0.258133,0.190644,0.000000,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.317218,0.317218,0.322877,0.319359,0.327277,0.356662,0.348067,0.348067,},
{0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.190644,0.289858,0.279214,0.292148,0.286917,0.297286,0.300125,0.000000,0.258133,0.190644,0.000000,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.317218,0.317218,0.322877,0.319359,0.327277,0.356662,0.348067,0.348067,},
{0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.190644,0.289858,0.279214,0.292148,0.286917,0.297286,0.300125,0.000000,0.258133,0.190644,0.000000,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.317218,0.317218,0.322877,0.319359,0.327277,0.356662,0.348067,0.348067,},
{0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.190644,0.289858,0.279214,0.292148,0.286917,0.297286,0.300125,0.000000,0.258133,0.190644,0.000000,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.317218,0.317218,0.322877,0.319359,0.327277,0.356662,0.348067,0.348067,},
{0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.190644,0.289858,0.279214,0.292148,0.286917,0.297286,0.300125,0.000000,0.258133,0.190644,0.000000,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.317218,0.317218,0.322877,0.319359,0.327277,0.356662,0.348067,0.348067,},
{0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.190644,0.289858,0.279214,0.292148,0.286917,0.297286,0.300125,0.000000,0.258133,0.190644,0.000000,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.317218,0.317218,0.322877,0.319359,0.327277,0.356662,0.348067,0.348067,},
{0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.190644,0.289858,0.279214,0.292148,0.286917,0.297286,0.300125,0.000000,0.258133,0.190644,0.000000,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.317218,0.317218,0.322877,0.319359,0.327277,0.356662,0.348067,0.348067,},
{0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.339967,0.190644,0.289858,0.279214,0.292148,0.286917,0.297286,0.300125,0.000000,0.258133,0.190644,0.000000,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.317218,0.317218,0.322877,0.319359,0.327277,0.356662,0.348067,0.348067,},
{0.190644,0.190644,0.190644,0.190644,0.190644,0.190644,0.190644,0.190644,0.190644,0.190644,0.190644,0.190644,0.190644,0.106908,0.162544,0.156575,0.163829,0.160895,0.166710,0.168302,0.000000,0.144754,0.106908,0.000000,0.186400,0.186400,0.186400,0.186400,0.186400,0.186400,0.186400,0.177887,0.177887,0.181061,0.179088,0.183528,0.200006,0.195186,0.195186,},
{0.289858,0.289858,0.289858,0.289858,0.289858,0.289858,0.289858,0.289858,0.289858,0.289858,0.289858,0.289858,0.289858,0.162544,0.247135,0.238059,0.249087,0.244628,0.253468,0.255889,0.000000,0.220086,0.162544,0.000000,0.283406,0.283406,0.283406,0.283406,0.283406,0.283406,0.283406,0.270463,0.270463,0.275288,0.272288,0.279039,0.304092,0.296764,0.296764,},
{0.279214,0.279214,0.279214,0.279214,0.279214,0.279214,0.279214,0.279214,0.279214,0.279214,0.279214,0.279214,0.279214,0.156575,0.238059,0.229317,0.239940,0.235644,0.244160,0.246492,0.000000,0.212004,0.156575,0.000000,0.272998,0.272998,0.272998,0.272998,0.272998,0.272998,0.272998,0.260530,0.260530,0.265178,0.262289,0.268791,0.292925,0.285866,0.285866,},
{0.292148,0.292148,0.292148,0.292148,0.292148,0.292148,0.292148,0.292148,0.292148,0.292148,0.292148,0.292148,0.292148,0.163829,0.249087,0.239940,0.251055,0.246560,0.255471,0.257910,0.000000,0.221825,0.163829,0.000000,0.285645,0.285645,0.285645,0.285645,0.285645,0.285645,0.285645,0.272599,0.272599,0.277462,0.274439,0.281243,0.306495,0.299108,0.299108,},
{0.286917,0.286917,0.286917,0.286917,0.286917,0.286917,0.286917,0.286917,0.286917,0.286917,0.286917,0.286917,0.286917,0.160895,0.244628,0.235644,0.246560,0.242146,0.250897,0.253293,0.000000,0.217853,0.160895,0.000000,0.280531,0.280531,0.280531,0.280531,0.280531,0.280531,0.280531,0.267719,0.267719,0.272495,0.269526,0.276208,0.301007,0.293753,0.293753,},
{0.297286,0.297286,0.297286,0.297286,0.297286,0.297286,0.297286,0.297286,0.297286,0.297286,0.297286,0.297286,0.297286,0.166710,0.253468,0.244160,0.255471,0.250897,0.259964,0.262447,0.000000,0.225726,0.166710,0.000000,0.290669,0.290669,0.290669,0.290669,0.290669,0.290669,0.290669,0.277394,0.277394,0.282342,0.279266,0.286190,0.311885,0.304369,0.304369,},
{0.300125,0.300125,0.300125,0.300125,0.300125,0.300125,0.300125,0.300125,0.300125,0.300125,0.300125,0.300125,0.300125,0.168302,0.255889,0.246492,0.257910,0.253293,0.262447,0.264953,0.000000,0.227882,0.168302,0.000000,0.293445,0.293445,0.293445,0.293445,0.293445,0.293445,0.293445,0.280043,0.280043,0.285039,0.281933,0.288923,0.314864,0.307276,0.307276,},
{0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,},
{0.258133,0.258133,0.258133,0.258133,0.258133,0.258133,0.258133,0.258133,0.258133,0.258133,0.258133,0.258133,0.258133,0.144754,0.220086,0.212004,0.221825,0.217853,0.225726,0.227882,0.000000,0.195998,0.144754,0.000000,0.252387,0.252387,0.252387,0.252387,0.252387,0.252387,0.252387,0.240861,0.240861,0.245157,0.242486,0.248498,0.270810,0.264283,0.264283,},
{0.190644,0.190644,0.190644,0.190644,0.190644,0.190644,0.190644,0.190644,0.190644,0.190644,0.190644,0.190644,0.190644,0.106908,0.162544,0.156575,0.163829,0.160895,0.166710,0.168302,0.000000,0.144754,0.106908,0.000000,0.186400,0.186400,0.186400,0.186400,0.186400,0.186400,0.186400,0.177887,0.177887,0.181061,0.179088,0.183528,0.200006,0.195186,0.195186,},
{0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,},
{0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.186400,0.283406,0.272998,0.285645,0.280531,0.290669,0.293445,0.000000,0.252387,0.186400,0.000000,0.325000,0.325000,0.325000,0.325000,0.325000,0.325000,0.325000,0.310157,0.310157,0.315690,0.312250,0.319992,0.348723,0.340318,0.340318,},
{0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.186400,0.283406,0.272998,0.285645,0.280531,0.290669,0.293445,0.000000,0.252387,0.186400,0.000000,0.325000,0.325000,0.325000,0.325000,0.325000,0.325000,0.325000,0.310157,0.310157,0.315690,0.312250,0.319992,0.348723,0.340318,0.340318,},
{0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.186400,0.283406,0.272998,0.285645,0.280531,0.290669,0.293445,0.000000,0.252387,0.186400,0.000000,0.325000,0.325000,0.325000,0.325000,0.325000,0.325000,0.325000,0.310157,0.310157,0.315690,0.312250,0.319992,0.348723,0.340318,0.340318,},
{0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.186400,0.283406,0.272998,0.285645,0.280531,0.290669,0.293445,0.000000,0.252387,0.186400,0.000000,0.325000,0.325000,0.325000,0.325000,0.325000,0.325000,0.325000,0.310157,0.310157,0.315690,0.312250,0.319992,0.348723,0.340318,0.340318,},
{0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.186400,0.283406,0.272998,0.285645,0.280531,0.290669,0.293445,0.000000,0.252387,0.186400,0.000000,0.325000,0.325000,0.325000,0.325000,0.325000,0.325000,0.325000,0.310157,0.310157,0.315690,0.312250,0.319992,0.348723,0.340318,0.340318,},
{0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.186400,0.283406,0.272998,0.285645,0.280531,0.290669,0.293445,0.000000,0.252387,0.186400,0.000000,0.325000,0.325000,0.325000,0.325000,0.325000,0.325000,0.325000,0.310157,0.310157,0.315690,0.312250,0.319992,0.348723,0.340318,0.340318,},
{0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.332399,0.186400,0.283406,0.272998,0.285645,0.280531,0.290669,0.293445,0.000000,0.252387,0.186400,0.000000,0.325000,0.325000,0.325000,0.325000,0.325000,0.325000,0.325000,0.310157,0.310157,0.315690,0.312250,0.319992,0.348723,0.340318,0.340318,},
{0.317218,0.317218,0.317218,0.317218,0.317218,0.317218,0.317218,0.317218,0.317218,0.317218,0.317218,0.317218,0.317218,0.177887,0.270463,0.260530,0.272599,0.267719,0.277394,0.280043,0.000000,0.240861,0.177887,0.000000,0.310157,0.310157,0.310157,0.310157,0.310157,0.310157,0.310157,0.295992,0.295992,0.301272,0.297990,0.305378,0.332796,0.324776,0.324776,},
{0.317218,0.317218,0.317218,0.317218,0.317218,0.317218,0.317218,0.317218,0.317218,0.317218,0.317218,0.317218,0.317218,0.177887,0.270463,0.260530,0.272599,0.267719,0.277394,0.280043,0.000000,0.240861,0.177887,0.000000,0.310157,0.310157,0.310157,0.310157,0.310157,0.310157,0.310157,0.295992,0.295992,0.301272,0.297990,0.305378,0.332796,0.324776,0.324776,},
{0.322877,0.322877,0.322877,0.322877,0.322877,0.322877,0.322877,0.322877,0.322877,0.322877,0.322877,0.322877,0.322877,0.181061,0.275288,0.265178,0.277462,0.272495,0.282342,0.285039,0.000000,0.245157,0.181061,0.000000,0.315690,0.315690,0.315690,0.315690,0.315690,0.315690,0.315690,0.301272,0.301272,0.306647,0.303306,0.310826,0.338733,0.330570,0.330570,},
{0.319359,0.319359,0.319359,0.319359,0.319359,0.319359,0.319359,0.319359,0.319359,0.319359,0.319359,0.319359,0.319359,0.179088,0.272288,0.262289,0.274439,0.269526,0.279266,0.281933,0.000000,0.242486,0.179088,0.000000,0.312250,0.312250,0.312250,0.312250,0.312250,0.312250,0.312250,0.297990,0.297990,0.303306,0.300001,0.307439,0.335042,0.326968,0.326968,},
{0.327277,0.327277,0.327277,0.327277,0.327277,0.327277,0.327277,0.327277,0.327277,0.327277,0.327277,0.327277,0.327277,0.183528,0.279039,0.268791,0.281243,0.276208,0.286190,0.288923,0.000000,0.248498,0.183528,0.000000,0.319992,0.319992,0.319992,0.319992,0.319992,0.319992,0.319992,0.305378,0.305378,0.310826,0.307439,0.315061,0.343349,0.335074,0.335074,},
{0.356662,0.356662,0.356662,0.356662,0.356662,0.356662,0.356662,0.356662,0.356662,0.356662,0.356662,0.356662,0.356662,0.200006,0.304092,0.292925,0.306495,0.301007,0.311885,0.314864,0.000000,0.270810,0.200006,0.000000,0.348723,0.348723,0.348723,0.348723,0.348723,0.348723,0.348723,0.332796,0.332796,0.338733,0.335042,0.343349,0.374177,0.365159,0.365159,},
{0.348067,0.348067,0.348067,0.348067,0.348067,0.348067,0.348067,0.348067,0.348067,0.348067,0.348067,0.348067,0.348067,0.195186,0.296764,0.285866,0.299108,0.293753,0.304369,0.307276,0.000000,0.264283,0.195186,0.000000,0.340318,0.340318,0.340318,0.340318,0.340318,0.340318,0.340318,0.324776,0.324776,0.330570,0.326968,0.335074,0.365159,0.356359,0.356359,},
{0.348067,0.348067,0.348067,0.348067,0.348067,0.348067,0.348067,0.348067,0.348067,0.348067,0.348067,0.348067,0.348067,0.195186,0.296764,0.285866,0.299108,0.293753,0.304369,0.307276,0.000000,0.264283,0.195186,0.000000,0.340318,0.340318,0.340318,0.340318,0.340318,0.340318,0.340318,0.324776,0.324776,0.330570,0.326968,0.335074,0.365159,0.356359,0.356359,}};

double epsilon[39][39] = {{0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.405835,0.359824,0.359824,0.153741,0.153741,0.153741,0.150275,0.150275,0.150275,0.153741,0.000000,0.153741,0.153741,0.000000,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.562277,0.562277,0.562813,0.505901,0.478526,0.548726,0.613495,0.613495,},
{0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.405835,0.359824,0.359824,0.153741,0.153741,0.153741,0.150275,0.150275,0.150275,0.153741,0.000000,0.153741,0.153741,0.000000,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.562277,0.562277,0.562813,0.505901,0.478526,0.548726,0.613495,0.613495,},
{0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.405835,0.359824,0.359824,0.153741,0.153741,0.153741,0.150275,0.150275,0.150275,0.153741,0.000000,0.153741,0.153741,0.000000,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.562277,0.562277,0.562813,0.505901,0.478526,0.548726,0.613495,0.613495,},
{0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.405835,0.359824,0.359824,0.153741,0.153741,0.153741,0.150275,0.150275,0.150275,0.153741,0.000000,0.153741,0.153741,0.000000,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.562277,0.562277,0.562813,0.505901,0.478526,0.548726,0.613495,0.613495,},
{0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.405835,0.359824,0.359824,0.153741,0.153741,0.153741,0.150275,0.150275,0.150275,0.153741,0.000000,0.153741,0.153741,0.000000,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.562277,0.562277,0.562813,0.505901,0.478526,0.548726,0.613495,0.613495,},
{0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.405835,0.359824,0.359824,0.153741,0.153741,0.153741,0.150275,0.150275,0.150275,0.153741,0.000000,0.153741,0.153741,0.000000,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.562277,0.562277,0.562813,0.505901,0.478526,0.548726,0.613495,0.613495,},
{0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.405835,0.359824,0.359824,0.153741,0.153741,0.153741,0.150275,0.150275,0.150275,0.153741,0.000000,0.153741,0.153741,0.000000,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.562277,0.562277,0.562813,0.505901,0.478526,0.548726,0.613495,0.613495,},
{0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.405835,0.359824,0.359824,0.153741,0.153741,0.153741,0.150275,0.150275,0.150275,0.153741,0.000000,0.153741,0.153741,0.000000,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.562277,0.562277,0.562813,0.505901,0.478526,0.548726,0.613495,0.613495,},
{0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.405835,0.359824,0.359824,0.153741,0.153741,0.153741,0.150275,0.150275,0.150275,0.153741,0.000000,0.153741,0.153741,0.000000,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.562277,0.562277,0.562813,0.505901,0.478526,0.548726,0.613495,0.613495,},
{0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.405835,0.359824,0.359824,0.153741,0.153741,0.153741,0.150275,0.150275,0.150275,0.153741,0.000000,0.153741,0.153741,0.000000,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.562277,0.562277,0.562813,0.505901,0.478526,0.548726,0.613495,0.613495,},
{0.405835,0.405835,0.405835,0.405835,0.405835,0.405835,0.405835,0.405835,0.405835,0.405835,0.457730,0.405835,0.405835,0.173400,0.173400,0.173400,0.169491,0.169491,0.169491,0.173400,0.000000,0.173400,0.173400,0.000000,0.570591,0.570591,0.570591,0.570591,0.570591,0.570591,0.570591,0.634177,0.634177,0.634780,0.570591,0.539716,0.618893,0.691943,0.691943,},
{0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.405835,0.359824,0.359824,0.153741,0.153741,0.153741,0.150275,0.150275,0.150275,0.153741,0.000000,0.153741,0.153741,0.000000,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.562277,0.562277,0.562813,0.505901,0.478526,0.548726,0.613495,0.613495,},
{0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.359824,0.405835,0.359824,0.359824,0.153741,0.153741,0.153741,0.150275,0.150275,0.150275,0.153741,0.000000,0.153741,0.153741,0.000000,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.562277,0.562277,0.562813,0.505901,0.478526,0.548726,0.613495,0.613495,},
{0.153741,0.153741,0.153741,0.153741,0.153741,0.153741,0.153741,0.153741,0.153741,0.153741,0.173400,0.153741,0.153741,0.065689,0.065689,0.065689,0.064208,0.064208,0.064208,0.065689,0.000000,0.065689,0.065689,0.000000,0.216155,0.216155,0.216155,0.216155,0.216155,0.216155,0.216155,0.240243,0.240243,0.240472,0.216155,0.204459,0.234453,0.262127,0.262127,},
{0.153741,0.153741,0.153741,0.153741,0.153741,0.153741,0.153741,0.153741,0.153741,0.153741,0.173400,0.153741,0.153741,0.065689,0.065689,0.065689,0.064208,0.064208,0.064208,0.065689,0.000000,0.065689,0.065689,0.000000,0.216155,0.216155,0.216155,0.216155,0.216155,0.216155,0.216155,0.240243,0.240243,0.240472,0.216155,0.204459,0.234453,0.262127,0.262127,},
{0.153741,0.153741,0.153741,0.153741,0.153741,0.153741,0.153741,0.153741,0.153741,0.153741,0.173400,0.153741,0.153741,0.065689,0.065689,0.065689,0.064208,0.064208,0.064208,0.065689,0.000000,0.065689,0.065689,0.000000,0.216155,0.216155,0.216155,0.216155,0.216155,0.216155,0.216155,0.240243,0.240243,0.240472,0.216155,0.204459,0.234453,0.262127,0.262127,},
{0.150275,0.150275,0.150275,0.150275,0.150275,0.150275,0.150275,0.150275,0.150275,0.150275,0.169491,0.150275,0.150275,0.064208,0.064208,0.064208,0.062760,0.062760,0.062760,0.064208,0.000000,0.064208,0.064208,0.000000,0.211282,0.211282,0.211282,0.211282,0.211282,0.211282,0.211282,0.234826,0.234826,0.235050,0.211282,0.199849,0.229167,0.256217,0.256217,},
{0.150275,0.150275,0.150275,0.150275,0.150275,0.150275,0.150275,0.150275,0.150275,0.150275,0.169491,0.150275,0.150275,0.064208,0.064208,0.064208,0.062760,0.062760,0.062760,0.064208,0.000000,0.064208,0.064208,0.000000,0.211282,0.211282,0.211282,0.211282,0.211282,0.211282,0.211282,0.234826,0.234826,0.235050,0.211282,0.199849,0.229167,0.256217,0.256217,},
{0.150275,0.150275,0.150275,0.150275,0.150275,0.150275,0.150275,0.150275,0.150275,0.150275,0.169491,0.150275,0.150275,0.064208,0.064208,0.064208,0.062760,0.062760,0.062760,0.064208,0.000000,0.064208,0.064208,0.000000,0.211282,0.211282,0.211282,0.211282,0.211282,0.211282,0.211282,0.234826,0.234826,0.235050,0.211282,0.199849,0.229167,0.256217,0.256217,},
{0.153741,0.153741,0.153741,0.153741,0.153741,0.153741,0.153741,0.153741,0.153741,0.153741,0.173400,0.153741,0.153741,0.065689,0.065689,0.065689,0.064208,0.064208,0.064208,0.065689,0.000000,0.065689,0.065689,0.000000,0.216155,0.216155,0.216155,0.216155,0.216155,0.216155,0.216155,0.240243,0.240243,0.240472,0.216155,0.204459,0.234453,0.262127,0.262127,},
{0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,},
{0.153741,0.153741,0.153741,0.153741,0.153741,0.153741,0.153741,0.153741,0.153741,0.153741,0.173400,0.153741,0.153741,0.065689,0.065689,0.065689,0.064208,0.064208,0.064208,0.065689,0.000000,0.065689,0.065689,0.000000,0.216155,0.216155,0.216155,0.216155,0.216155,0.216155,0.216155,0.240243,0.240243,0.240472,0.216155,0.204459,0.234453,0.262127,0.262127,},
{0.153741,0.153741,0.153741,0.153741,0.153741,0.153741,0.153741,0.153741,0.153741,0.153741,0.173400,0.153741,0.153741,0.065689,0.065689,0.065689,0.064208,0.064208,0.064208,0.065689,0.000000,0.065689,0.065689,0.000000,0.216155,0.216155,0.216155,0.216155,0.216155,0.216155,0.216155,0.240243,0.240243,0.240472,0.216155,0.204459,0.234453,0.262127,0.262127,},
{0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,},
{0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.570591,0.505901,0.505901,0.216155,0.216155,0.216155,0.211282,0.211282,0.211282,0.216155,0.000000,0.216155,0.216155,0.000000,0.711280,0.711280,0.711280,0.711280,0.711280,0.711280,0.711280,0.790544,0.790544,0.791296,0.711280,0.672792,0.771491,0.862554,0.862554,},
{0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.570591,0.505901,0.505901,0.216155,0.216155,0.216155,0.211282,0.211282,0.211282,0.216155,0.000000,0.216155,0.216155,0.000000,0.711280,0.711280,0.711280,0.711280,0.711280,0.711280,0.711280,0.790544,0.790544,0.791296,0.711280,0.672792,0.771491,0.862554,0.862554,},
{0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.570591,0.505901,0.505901,0.216155,0.216155,0.216155,0.211282,0.211282,0.211282,0.216155,0.000000,0.216155,0.216155,0.000000,0.711280,0.711280,0.711280,0.711280,0.711280,0.711280,0.711280,0.790544,0.790544,0.791296,0.711280,0.672792,0.771491,0.862554,0.862554,},
{0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.570591,0.505901,0.505901,0.216155,0.216155,0.216155,0.211282,0.211282,0.211282,0.216155,0.000000,0.216155,0.216155,0.000000,0.711280,0.711280,0.711280,0.711280,0.711280,0.711280,0.711280,0.790544,0.790544,0.791296,0.711280,0.672792,0.771491,0.862554,0.862554,},
{0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.570591,0.505901,0.505901,0.216155,0.216155,0.216155,0.211282,0.211282,0.211282,0.216155,0.000000,0.216155,0.216155,0.000000,0.711280,0.711280,0.711280,0.711280,0.711280,0.711280,0.711280,0.790544,0.790544,0.791296,0.711280,0.672792,0.771491,0.862554,0.862554,},
{0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.570591,0.505901,0.505901,0.216155,0.216155,0.216155,0.211282,0.211282,0.211282,0.216155,0.000000,0.216155,0.216155,0.000000,0.711280,0.711280,0.711280,0.711280,0.711280,0.711280,0.711280,0.790544,0.790544,0.791296,0.711280,0.672792,0.771491,0.862554,0.862554,},
{0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.570591,0.505901,0.505901,0.216155,0.216155,0.216155,0.211282,0.211282,0.211282,0.216155,0.000000,0.216155,0.216155,0.000000,0.711280,0.711280,0.711280,0.711280,0.711280,0.711280,0.711280,0.790544,0.790544,0.791296,0.711280,0.672792,0.771491,0.862554,0.862554,},
{0.562277,0.562277,0.562277,0.562277,0.562277,0.562277,0.562277,0.562277,0.562277,0.562277,0.634177,0.562277,0.562277,0.240243,0.240243,0.240243,0.234826,0.234826,0.234826,0.240243,0.000000,0.240243,0.240243,0.000000,0.790544,0.790544,0.790544,0.790544,0.790544,0.790544,0.790544,0.878640,0.878640,0.879477,0.790544,0.747766,0.857465,0.958675,0.958675,},
{0.562277,0.562277,0.562277,0.562277,0.562277,0.562277,0.562277,0.562277,0.562277,0.562277,0.634177,0.562277,0.562277,0.240243,0.240243,0.240243,0.234826,0.234826,0.234826,0.240243,0.000000,0.240243,0.240243,0.000000,0.790544,0.790544,0.790544,0.790544,0.790544,0.790544,0.790544,0.878640,0.878640,0.879477,0.790544,0.747766,0.857465,0.958675,0.958675,},
{0.562813,0.562813,0.562813,0.562813,0.562813,0.562813,0.562813,0.562813,0.562813,0.562813,0.634780,0.562813,0.562813,0.240472,0.240472,0.240472,0.235050,0.235050,0.235050,0.240472,0.000000,0.240472,0.240472,0.000000,0.791296,0.791296,0.791296,0.791296,0.791296,0.791296,0.791296,0.879477,0.879477,0.880314,0.791296,0.748478,0.858281,0.959588,0.959588,},
{0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.505901,0.570591,0.505901,0.505901,0.216155,0.216155,0.216155,0.211282,0.211282,0.211282,0.216155,0.000000,0.216155,0.216155,0.000000,0.711280,0.711280,0.711280,0.711280,0.711280,0.711280,0.711280,0.790544,0.790544,0.791296,0.711280,0.672792,0.771491,0.862554,0.862554,},
{0.478526,0.478526,0.478526,0.478526,0.478526,0.478526,0.478526,0.478526,0.478526,0.478526,0.539716,0.478526,0.478526,0.204459,0.204459,0.204459,0.199849,0.199849,0.199849,0.204459,0.000000,0.204459,0.204459,0.000000,0.672792,0.672792,0.672792,0.672792,0.672792,0.672792,0.672792,0.747766,0.747766,0.748478,0.672792,0.636386,0.729745,0.815880,0.815880,},
{0.548726,0.548726,0.548726,0.548726,0.548726,0.548726,0.548726,0.548726,0.548726,0.548726,0.618893,0.548726,0.548726,0.234453,0.234453,0.234453,0.229167,0.229167,0.229167,0.234453,0.000000,0.234453,0.234453,0.000000,0.771491,0.771491,0.771491,0.771491,0.771491,0.771491,0.771491,0.857465,0.857465,0.858281,0.771491,0.729745,0.836800,0.935571,0.935571,},
{0.613495,0.613495,0.613495,0.613495,0.613495,0.613495,0.613495,0.613495,0.613495,0.613495,0.691943,0.613495,0.613495,0.262127,0.262127,0.262127,0.256217,0.256217,0.256217,0.262127,0.000000,0.262127,0.262127,0.000000,0.862554,0.862554,0.862554,0.862554,0.862554,0.862554,0.862554,0.958675,0.958675,0.959588,0.862554,0.815880,0.935571,1.046000,1.046000,},
{0.613495,0.613495,0.613495,0.613495,0.613495,0.613495,0.613495,0.613495,0.613495,0.613495,0.691943,0.613495,0.613495,0.262127,0.262127,0.262127,0.256217,0.256217,0.256217,0.262127,0.000000,0.262127,0.262127,0.000000,0.862554,0.862554,0.862554,0.862554,0.862554,0.862554,0.862554,0.958675,0.958675,0.959588,0.862554,0.815880,0.935571,1.046000,1.046000,}};

void print_peptide(int start, int max, int model){
 int x,y,z;

 z=1;
 printf("MODEL   %d\n",model);
 for(x=start;x<max;x++){
    for(y=0;y<peptide[x].num_side;y++){
        printf("ATOM%7d  %-4s%-s A%4d    %8.3lf%8.3lf%8.3lf               \n",z,peptide[x].side_chain[y].name,peptide[x].name,peptide[x].ac_num,peptide[x].side_chain[y].x,peptide[x].side_chain[y].y,peptide[x].side_chain[y].z);
        z++;
    }
 }
 printf("ENDMDL\n");
}

void print_peptide_file(int start, int max, int model,FILE *fil){
 int x,y,z;

 z=1;
 fprintf(fil,"MODEL   %d\n",model);
 for(x=start;x<max;x++){
    for(y=0;y<peptide[x].num_side;y++){
        fprintf(fil,"ATOM%7d  %-4s%-s A%4d    %8.3lf%8.3lf%8.3lf               \n",z,peptide[x].side_chain[y].name,peptide[x].name,peptide[x].ac_num,peptide[x].side_chain[y].x,peptide[x].side_chain[y].y,peptide[x].side_chain[y].z);
        z++;
    }
 }
 fprintf(fil,"ENDMDL\n");
}
double get_non_ideal(double phi, double psi){
 if(phi < 0){
    return 111.2;
 }
 else{
    return 115.0;
 }
}

float update_bonded_energy(){

}

float update_nonbonded_energy(){

}


void rot_coord(struct Atom *src, struct Atom axis, double thet){

 double abs,matrix[3][3],ang,inp[3],co,si,p,q,r;
 int a,b;

 inp[0] = src->x;inp[1] = src->y;inp[2] = src->z; // To make calculation easier later, put the coords in an array
 p = axis.x;q=axis.y;r=axis.z;
 abs = sqrt(pow(p,2) + pow(q,2) + pow(r,2)); // Magnitude of the axis vector
 p = p/abs;q = q/abs;r = r/abs;  //Normalise the coords of the axis to get unit vector in direction of axis
 ang = (thet/180.0) * M_PI;
 co=cosf(ang);
 si=sinf(ang);

 //printf("Cos = %.4f  ||  Sin = %.4f\n",co,si);
 //printf("X = %.3f, Y = %.3f, Z = %.3f\n",p,q,r);
// Now the construction of the matrix. Check and double check this as everything depends on it !!


 matrix[0][0]= 1 + ((1-co)*(pow(p,2) - 1));
 matrix[0][1]= ((1-co)*(p*q)) - (r*si);
 matrix[0][2]= ((1-co)*(p*r)) + (q*si);

 matrix[1][0]= ((1-co)*(p*q)) + (r*si);
 matrix[1][1]= 1 + ((1-co)*(pow(q,2) - 1));
 matrix[1][2]= ((1-co)*(r*q)) - (p*si);

 matrix[2][0]= ((1-co)*(p*r)) - (q*si);
 matrix[2][1]= ((1-co)*(q*r)) + (p*si);
 matrix[2][2]= 1 + ((1-co)*(pow(r,2) - 1));

 for(a=0;a<3;++a){
    abs=0.0;
    for(b=0;b<3;++b)
       abs = abs + (matrix[a][b] * inp[b]);

    if(a==0){
    src->x = abs;
    }
    else if(a==1){
    src->y =abs;
    }
    else if(a==2){
    src->z =abs;
    }
 }
}

/* Function will take a 'haystack' string and copy contents from start to end to another string pointed to by needle. The first string 'haystak' should be a string, whereas the needle should be a pointer to a string. */

void copy_substr(char *hay, char *needle, int start, int end){
 int x,y;
 char temp[100];
 if(start < end){
        y=0;
        for(x=start;x<end;x++){
                temp[y] = hay[x];
                y++;
        }
        temp[y]='\0';
        strcpy(needle,temp);
 }
 else{
        fprintf(stderr,"Serious error detected in use of copy_substr() function. The program has exited. Please contact okdev for answers and a solution\n");
        exit(1);
 }
}

double get_distance(struct Atom at1, struct Atom at2){

 return sqrt(pow(at1.x - at2.x,2) + pow(at1.y - at2.y,2) + pow(at1.z - at2.z,2));
}

/* Function to give the index of the amino acid in single letter code. */
int get_amino1_index(char aa){
 int ans,x;
 x=0;ans =-1;
 while(x<20){
    if(aa == amino_single[x]){
        ans = x;
    }
    x++;
 }
 return ans;
}


/* Function to give the index of the amino acid in three letter code. */
int get_amino3_index(char *nam){
 int x,ans;
 ans=-1;

 for(x=0;x<20;x++){
    if(strcmp(nam,amino_acids[x]) == 0){
        return x;
    }
 }
 return ans;
}

void cross_product(struct Atom* src, struct Atom vec1, struct Atom vec2){
 double x,y,z;

 src->x = (vec1.y*vec2.z) - (vec1.z*vec2.y);
 src->y = (vec1.z*vec2.x) - (vec1.x*vec2.z);
 src->z = (vec1.x*vec2.y) - (vec1.y*vec2.x);
}

/*double dot_product(struct Atom atom1, struct Atom atom2){
    double ans=0.0;
    ans=((atom1.x)*(atom2.x))+((atom1.y)*(atom2.y))+((atom1.z)*(atom2.z));
    return ans;
}
*/

void translate_vec(struct Atom* src, struct Atom ref){
 double x,y,z;
 x=src->x;y=src->y;z=src->z;

 src->x = x - ref.x;
 src->y = y - ref.y;
 src->z = z - ref.z;
}

double angle_bet_vectors(struct Atom at1, struct Atom at2){
    double dot,abs1,abs2,angle;

    angle=0.0;
    dot = (at1.x*at2.x) + (at1.y*at2.y) + (at1.z*at2.z);
    abs1 = sqrt(pow(at1.x,2) + pow(at1.y,2) + pow(at1.z,2));
    abs2 = sqrt(pow(at2.x,2) + pow(at2.y,2) + pow(at2.z,2));

    angle = (180.0*((acos(dot/(abs1*abs2)))/M_PI));

    return angle;
}

double calc_torsion(struct Atom tmp1,struct Atom tmp2,struct Atom tmp3,struct Atom tmp4){
 struct Atom vec1,vec2,ans,tmp;
 double ang;

 translate_vec(&tmp1,tmp2);
 translate_vec(&tmp3,tmp2);
 translate_vec(&tmp4,tmp2);
 translate_vec(&tmp2,tmp2);

 vec1.x = tmp2.x-tmp3.x;vec1.y=tmp2.y-tmp3.y;vec1.z=tmp2.z-tmp3.z;
 vec2.x = tmp2.x-tmp1.x;vec2.y=tmp2.y-tmp1.y;vec2.z=tmp2.z-tmp1.z;

 cross_product(&ans,vec1,vec2);
 tmp.x=0.0;tmp.y=0.0;tmp.z=1.0;
 ang = angle_bet_vectors(ans,tmp);
 cross_product(&vec1,ans,tmp);

 rot_coord(&tmp1, vec1 ,ang);
 rot_coord(&tmp2, vec1 ,ang);
 rot_coord(&tmp3, vec1 ,ang);
 rot_coord(&tmp4, vec1 ,ang);

 cross_product(&vec1,tmp1,tmp3);
 ans.x = tmp2.x-tmp3.x;ans.y=tmp2.y-tmp3.y;ans.z=tmp2.z-tmp3.z;
 tmp.x = tmp4.x-tmp3.x;tmp.y=tmp4.y-tmp3.y;tmp.z=tmp4.z-tmp3.z;

 cross_product(&vec2,ans,tmp);
 ang = angle_bet_vectors(vec2,vec1);


 if(tmp4.z == 0 && ang == 0.0){
    return 0.0;
 }
 else{
    if(tmp4.z > 0){
        return ang;
    }
    else{
       return -1*ang;
    }
 }
}

void make_non_ideal(int i){
 int x,y,z;
 int phi_x,psi_x, n_in;
 struct Atom vec[5],prev,curr,trans,rot_axis,tr_axis;;
 double ang;

 if(ncac_angles[i][1] != 180.0){  // This is the block for non-ideal Omega angles.
    x=peptide[i].main_chain[3];
    trans.x = peptide[i].side_chain[x].x;
    trans.y = peptide[i].side_chain[x].y;
    trans.z = peptide[i].side_chain[x].z;
    
    prev.x = peptide[i].next_one[1].x-trans.x;
    prev.y = peptide[i].next_one[1].y-trans.y;
    prev.z = peptide[i].next_one[1].z-trans.z;

    if(ncac_angles[i][1] > 0){
        ang = ncac_angles[i][1] - 180.0;
    }
    else{
        ang = 180 - fabs(ncac_angles[i][1]);
    }

    peptide[i].next_one[0].x -= trans.x;
    peptide[i].next_one[0].y -= trans.y;
    peptide[i].next_one[0].z -= trans.z;
 
    peptide[i].next_one[2].x -= trans.x;
    peptide[i].next_one[2].y -= trans.y;
    peptide[i].next_one[2].z -= trans.z;

    rot_coord(&peptide[i].next_one[0],prev,ang);
    rot_coord(&peptide[i].next_one[2],prev,ang);

    peptide[i].next_one[0].x += trans.x;
    peptide[i].next_one[0].y += trans.y;
    peptide[i].next_one[0].z += trans.z;
 
    peptide[i].next_one[2].x += trans.x;
    peptide[i].next_one[2].y += trans.y;
    peptide[i].next_one[2].z += trans.z;
 }


 if(ncac_angles[i][6] != -1){ // This is the N-Ca distance.
    x=peptide[i].main_chain[1]; // This is N atom
    trans.x = peptide[i].side_chain[x].x;
    trans.y = peptide[i].side_chain[x].y;
    trans.z = peptide[i].side_chain[x].z;
    x=peptide[i].main_chain[2];
    //This is CA atom. And the vector in the direction of the N_CA distance.
    curr.x = peptide[i].side_chain[x].x-trans.x;
    curr.y = peptide[i].side_chain[x].y-trans.y;
    curr.z = peptide[i].side_chain[x].z-trans.z;
    ang = sqrt(pow(curr.x,2)+pow(curr.y,2)+pow(curr.z,2));

    prev.x=curr.x;prev.y=curr.y;prev.z=curr.z;
    
    curr.x = (ncac_angles[i][6]*curr.x)/ang;
    curr.y = (ncac_angles[i][6]*curr.y)/ang;
    curr.z = (ncac_angles[i][6]*curr.z)/ang;
   
    tr_axis.x = prev.x-curr.x;
    tr_axis.y = prev.y-curr.y;
    tr_axis.z = prev.z-curr.z;

    for(x=0;x<peptide[i].num_side;x++){
        if(x != peptide[i].main_chain[0] && x!= peptide[i].main_chain[1]){
            peptide[i].side_chain[x].x = peptide[i].side_chain[x].x - tr_axis.x;
            peptide[i].side_chain[x].y = peptide[i].side_chain[x].y - tr_axis.y;
            peptide[i].side_chain[x].z = peptide[i].side_chain[x].z - tr_axis.z;
        }
    }
    for(x=0;x<3;x++){
        peptide[i].next_one[x].x = peptide[i].next_one[x].x - tr_axis.x;
        peptide[i].next_one[x].y = peptide[i].next_one[x].y - tr_axis.y;
        peptide[i].next_one[x].z = peptide[i].next_one[x].z - tr_axis.z;
    }
 }

 if(ncac_angles[i][7] != -1){ // This is the Ca-C distance.
    x=peptide[i].main_chain[2]; // This is CA atom
    trans.x = peptide[i].side_chain[x].x;
    trans.y = peptide[i].side_chain[x].y;
    trans.z = peptide[i].side_chain[x].z;
    x=peptide[i].main_chain[3];
    //This is C atom. And the vector in the direction of the CA_C distance.
    curr.x = peptide[i].side_chain[x].x-trans.x;
    curr.y = peptide[i].side_chain[x].y-trans.y;
    curr.z = peptide[i].side_chain[x].z-trans.z;
    ang = sqrt(pow(curr.x,2)+pow(curr.y,2)+pow(curr.z,2));

    prev.x=curr.x;prev.y=curr.y;prev.z=curr.z;
    
    curr.x = (ncac_angles[i][7]*curr.x)/ang;
    curr.y = (ncac_angles[i][7]*curr.y)/ang;
    curr.z = (ncac_angles[i][7]*curr.z)/ang;
   
    tr_axis.x = prev.x-curr.x;
    tr_axis.y = prev.y-curr.y;
    tr_axis.z = prev.z-curr.z;

    x=peptide[i].main_chain[3];
    peptide[i].side_chain[x].x = peptide[i].side_chain[x].x - tr_axis.x;
    peptide[i].side_chain[x].y = peptide[i].side_chain[x].y - tr_axis.y;
    peptide[i].side_chain[x].z = peptide[i].side_chain[x].z - tr_axis.z;
    
    x=peptide[i].main_chain[4];
    peptide[i].side_chain[x].x = peptide[i].side_chain[x].x - tr_axis.x;
    peptide[i].side_chain[x].y = peptide[i].side_chain[x].y - tr_axis.y;
    peptide[i].side_chain[x].z = peptide[i].side_chain[x].z - tr_axis.z;

    for(x=0;x<3;x++){
        peptide[i].next_one[x].x = peptide[i].next_one[x].x - tr_axis.x;
        peptide[i].next_one[x].y = peptide[i].next_one[x].y - tr_axis.y;
        peptide[i].next_one[x].z = peptide[i].next_one[x].z - tr_axis.z;
    }
 }

 if(ncac_angles[i][8] != -1){ // This is the C-N distance.
    x=peptide[i].main_chain[3]; // This is C atom
    trans.x = peptide[i].side_chain[x].x;
    trans.y = peptide[i].side_chain[x].y;
    trans.z = peptide[i].side_chain[x].z;
    //This is N1 atom. And the vector in the direction of the C-N1 distance.
    curr.x = peptide[i].next_one[1].x-trans.x;
    curr.y = peptide[i].next_one[1].y-trans.y;
    curr.z = peptide[i].next_one[1].z-trans.z;
    ang = sqrt(pow(curr.x,2)+pow(curr.y,2)+pow(curr.z,2));

    prev.x=curr.x;prev.y=curr.y;prev.z=curr.z;
    
    
    curr.x = (ncac_angles[i][8]*curr.x)/ang;
    curr.y = (ncac_angles[i][8]*curr.y)/ang;
    curr.z = (ncac_angles[i][8]*curr.z)/ang;
   
    tr_axis.x = prev.x-curr.x;
    tr_axis.y = prev.y-curr.y;
    tr_axis.z = prev.z-curr.z;

    for(x=0;x<3;x++){
        peptide[i].next_one[x].x = peptide[i].next_one[x].x - tr_axis.x;
        peptide[i].next_one[x].y = peptide[i].next_one[x].y - tr_axis.y;
        peptide[i].next_one[x].z = peptide[i].next_one[x].z - tr_axis.z;
    }

 }
 
 if(ncac_angles[i][0] != 0){ // This is the block for N-Ca-C angles.
    x=peptide[i].main_chain[2];
    trans.x = peptide[i].side_chain[x].x;
    trans.y = peptide[i].side_chain[x].y;
    trans.z = peptide[i].side_chain[x].z;
 
    x=peptide[i].main_chain[1];// This is the N atom. So first we will get the N-Ca vector.
    prev.x = peptide[i].side_chain[x].x-trans.x;
    prev.y = peptide[i].side_chain[x].y-trans.y;
    prev.z = peptide[i].side_chain[x].z-trans.z;
  
    x=peptide[i].main_chain[3];// This is the C atom. Second, we will get the Ca-C vector.
    curr.x = peptide[i].side_chain[x].x-trans.x;
    curr.y = peptide[i].side_chain[x].y-trans.y;
    curr.z = peptide[i].side_chain[x].z-trans.z;
    
    cross_product(&rot_axis, prev, curr);
    ang = (ncac_angles[i][0] - angle_bet_vectors(prev,curr));
    //fprintf(stderr,"NCaC rot by %f\n",ang);
    x=peptide[i].main_chain[3];
    rot_coord(&peptide[i].side_chain[x],rot_axis,ang);
    x=peptide[i].main_chain[4];
    rot_coord(&peptide[i].side_chain[x],rot_axis,ang);
    rot_coord(&peptide[i].next_one[0],rot_axis,ang);
    rot_coord(&peptide[i].next_one[1],rot_axis,ang);
    rot_coord(&peptide[i].next_one[2],rot_axis,ang);
 }

 /*if(ncac_angles[i][5] != 0){ // This is the block for O-C-Ca angles.
    x=peptide[i].main_chain[3];
    trans.x = peptide[i].side_chain[x].x;
    trans.y = peptide[i].side_chain[x].y;
    trans.z = peptide[i].side_chain[x].z;
 
    x=peptide[i].main_chain[4];// This is the O atom. 
    prev.x = peptide[i].side_chain[x].x-trans.x;
    prev.y = peptide[i].side_chain[x].y-trans.y;
    prev.z = peptide[i].side_chain[x].z-trans.z;
  
    x=peptide[i].main_chain[2];// This is the C atom. Second, we will get the Ca-C vector.
    curr.x = peptide[i].side_chain[x].x-trans.x;
    curr.y = peptide[i].side_chain[x].y-trans.y;
    curr.z = peptide[i].side_chain[x].z-trans.z;
    
    cross_product(&rot_axis, prev, curr);
    ang = (ncac_angles[i][5] - angle_bet_vectors(prev,curr));
    //fprintf(stderr,"NCaC rot by %f\n",ang);
    x=peptide[i].main_chain[4];
    rot_coord(&peptide[i].side_chain[x],rot_axis,ang);
 }*/
 if(ncac_angles[i][4] != 0){ // This is the block for CA-C-N1 angles.
    x=peptide[i].main_chain[3]; // This is C atom
    trans.x = peptide[i].side_chain[x].x;
    trans.y = peptide[i].side_chain[x].y;
    trans.z = peptide[i].side_chain[x].z;
 
    x=peptide[i].main_chain[2];// This is the CA atom. So first we will get the N-Ca vector.
    prev.x = peptide[i].side_chain[x].x-trans.x;
    prev.y = peptide[i].side_chain[x].y-trans.y;
    prev.z = peptide[i].side_chain[x].z-trans.z;
  
    //This is N1 atom.
    curr.x = peptide[i].next_one[1].x-trans.x;
    curr.y = peptide[i].next_one[1].y-trans.y;
    curr.z = peptide[i].next_one[1].z-trans.z;

    cross_product(&rot_axis, prev, curr);
    ang = (ncac_angles[i][4] - angle_bet_vectors(prev,curr));
 
    peptide[i].next_one[0].x -= trans.x;
    peptide[i].next_one[0].y -= trans.y;
    peptide[i].next_one[0].z -= trans.z;
    peptide[i].next_one[1].x -= trans.x;
    peptide[i].next_one[1].y -= trans.y;
    peptide[i].next_one[1].z -= trans.z;
    peptide[i].next_one[2].x -= trans.x;
    peptide[i].next_one[2].y -= trans.y;
    peptide[i].next_one[2].z -= trans.z;

    rot_coord(&peptide[i].next_one[0],rot_axis,ang);
    rot_coord(&peptide[i].next_one[1],rot_axis,ang);
    rot_coord(&peptide[i].next_one[2],rot_axis,ang);

    peptide[i].next_one[0].x += trans.x;
    peptide[i].next_one[0].y += trans.y;
    peptide[i].next_one[0].z += trans.z;
    peptide[i].next_one[1].x += trans.x;
    peptide[i].next_one[1].y += trans.y;
    peptide[i].next_one[1].z += trans.z;
    peptide[i].next_one[2].x += trans.x;
    peptide[i].next_one[2].y += trans.y;
    peptide[i].next_one[2].z += trans.z;
 }
 if(ncac_angles[i][2] != 0){ // This is the block for O-C-N1 angles.
    // This is C atom
    x=peptide[i].main_chain[3];
    trans.x = peptide[i].side_chain[x].x;
    trans.y = peptide[i].side_chain[x].y;
    trans.z = peptide[i].side_chain[x].z;
 
    x=peptide[i].main_chain[4];// This is the O atom.
    prev.x = peptide[i].side_chain[x].x-trans.x;
    prev.y = peptide[i].side_chain[x].y-trans.y;
    prev.z = peptide[i].side_chain[x].z-trans.z;
  
    //This is the N1 atom.
    curr.x = peptide[i].next_one[1].x-trans.x;
    curr.y = peptide[i].next_one[1].y-trans.y;
    curr.z = peptide[i].next_one[1].z-trans.z;

    cross_product(&rot_axis, prev, curr);
    ang = (ncac_angles[i][2] - angle_bet_vectors(prev,curr));
 
    x=peptide[i].main_chain[4];// This is the O atom.
    peptide[i].side_chain[x].x -= trans.x;
    peptide[i].side_chain[x].y -= trans.y;
    peptide[i].side_chain[x].z -= trans.z;

    rot_coord(&peptide[i].side_chain[x],rot_axis,ang);

    peptide[i].side_chain[x].x += trans.x;
    peptide[i].side_chain[x].y += trans.y;
    peptide[i].side_chain[x].z += trans.z;
 }
 if(ncac_angles[i][3] != 0){ // This is the block for C-N1-CA1 angles.
    // This is N1 atom
    trans.x = peptide[i].next_one[1].x;
    trans.y = peptide[i].next_one[1].y;
    trans.z = peptide[i].next_one[1].z;
 
    x=peptide[i].main_chain[3];// This is the C atom.
    prev.x = peptide[i].side_chain[x].x-trans.x;
    prev.y = peptide[i].side_chain[x].y-trans.y;
    prev.z = peptide[i].side_chain[x].z-trans.z;
  
    //This is the CA1 atom.
    curr.x = peptide[i].next_one[0].x-trans.x;
    curr.y = peptide[i].next_one[0].y-trans.y;
    curr.z = peptide[i].next_one[0].z-trans.z;

    cross_product(&rot_axis, prev, curr);
    ang = (ncac_angles[i][3] - angle_bet_vectors(prev,curr));
 
    peptide[i].next_one[0].x -= trans.x;
    peptide[i].next_one[0].y -= trans.y;
    peptide[i].next_one[0].z -= trans.z;

    rot_coord(&peptide[i].next_one[0],rot_axis,ang);

    peptide[i].next_one[0].x += trans.x;
    peptide[i].next_one[0].y += trans.y;
    peptide[i].next_one[0].z += trans.z;
 }

}

void set_rotation_side(int i, int chival, int *cen, int *rot){
 int x;

 if(chival == 0){
     *cen = peptide[i].main_chain[2]; 
    for(x=0;x<peptide[i].num_side;x++){
        if(strcmp(peptide[i].side_chain[x].name,"CB") == 0){
            *rot = x;
        }
    }
 }  
 if(chival == 1){
    for(x=0;x<peptide[i].num_side;x++){
        if(strcmp(peptide[i].side_chain[x].name,"CB") == 0){
            *cen = x;
        }
    }
    if(strcmp(peptide[i].name,"ILE") == 0){
        for(x=0;x<peptide[i].num_side;x++){
           if(strcmp(peptide[i].side_chain[x].name,"CG1") == 0){
                *rot = x;
            }
        }
    }
    else{
        for(x=0;x<peptide[i].num_side;x++){
           if(strcmp(peptide[i].side_chain[x].name,"CG") == 0){
                *rot = x;
            }
        }
    }
 }  
 if(chival == 2){
    for(x=0;x<peptide[i].num_side;x++){
        if(strcmp(peptide[i].side_chain[x].name,"CG") == 0){
            *cen = x;
        }
    }
    if(strcmp(peptide[i].name,"MET") == 0){
        for(x=0;x<peptide[i].num_side;x++){
           if(strcmp(peptide[i].side_chain[x].name,"SD") == 0){
                *rot = x;
            }
        }
    }
    else{
        for(x=0;x<peptide[i].num_side;x++){
           if(strcmp(peptide[i].side_chain[x].name,"CD") == 0){
                *rot = x;
            }
        }
    }
 }  
 if(chival == 3){
    for(x=0;x<peptide[i].num_side;x++){
        if(strcmp(peptide[i].side_chain[x].name,"CD") == 0){
            *cen = x;
        }
    }
    if(strcmp(peptide[i].name,"ARG") == 0){
        for(x=0;x<peptide[i].num_side;x++){
           if(strcmp(peptide[i].side_chain[x].name,"NE") == 0){
                *rot = x;
            }
        }
    }
    else{
        for(x=0;x<peptide[i].num_side;x++){
           if(strcmp(peptide[i].side_chain[x].name,"CE") == 0){
                *rot = x;
            }
        }
    }
 }  
 if(chival == 1){
    for(x=0;x<peptide[i].num_side;x++){
        if(strcmp(peptide[i].side_chain[x].name,"NE") == 0){
            *cen = x;
        }
    }
    for(x=0;x<peptide[i].num_side;x++){
       if(strcmp(peptide[i].side_chain[x].name,"CZ") == 0){
            *rot = x;
        }
    }
 }  
 
}

// The side-chain rotamer thingy with fine details. The first is the chival which will set the level of the chi. If chi0, then rotate everything that is 0 and above. So, the calling function should make sure that a residue chi value is appropriate. Maybe we can set a max_chi for each residue just like max_side.
//
// The algorithm for the function is to take the appropriate center and vector and then rotate everything.
//
void rotate_side_chain(int chival, int i, double ang){
 int x,y,z,p,q;
 struct Atom prev,curr,trans,rot_axis;

 //Get this  depending on the level and the residue type. This is just to ensure that the function remains clean.
 p=-1;q=-1;
 set_rotation_side(i, chival, &p, &q);
 if(p != -1 && q != -1){
    trans.x = peptide[i].side_chain[p].x; 
    trans.y = peptide[i].side_chain[p].y; 
    trans.z = peptide[i].side_chain[p].z; 

    rot_axis.x =  peptide[i].side_chain[q].x - trans.x;
    rot_axis.y =  peptide[i].side_chain[q].y - trans.y;
    rot_axis.z =  peptide[i].side_chain[q].z - trans.z;

    for(x=0;x<peptide[i].num_side;x++){
        if(peptide[i].side_chain[x].chi >= chival){
            //fprintf(stderr,"Yahan aaya %d %s\n",i,peptide[i].side_chain[x].name);
            peptide[i].side_chain[x].x = peptide[i].side_chain[x].x - trans.x;
            peptide[i].side_chain[x].y = peptide[i].side_chain[x].y - trans.y;
            peptide[i].side_chain[x].z = peptide[i].side_chain[x].z - trans.z;
            rot_coord(&peptide[i].side_chain[x],rot_axis,ang);
            peptide[i].side_chain[x].x = peptide[i].side_chain[x].x + trans.x;
            peptide[i].side_chain[x].y = peptide[i].side_chain[x].y + trans.y;
            peptide[i].side_chain[x].z = peptide[i].side_chain[x].z + trans.z;
        }
    }
 }
}

// The phi/psi rotation function. The entire peptide needs to be rotated.
//
void rotate_torsion(double phival, double psival, int i){
// Rotate the master thingy with phi angle and psi angle.
 int x,y,z;
 int phi_x,psi_x, n_in;
 struct Atom vec[5],prev,curr,trans,rot_axis;
 double ang;
 
 //First rotate by phi.
 if(i > 0){
    phi_x = peptide[i].main_chain[1];
    for(x=0;x<peptide[i].num_side;x++){
        if(x!= peptide[i].main_chain[0] && x!=peptide[i].main_chain[1] && x!=peptide[i].main_chain[2]){
            rot_coord(&peptide[i].side_chain[x],peptide[i].side_chain[phi_x],-1.0*phival);
        }
    }
    for(x=0;x<3;x++)
        rot_coord(&peptide[i].next_one[x],peptide[i].side_chain[phi_x],-1.0*phival);
 }
 //Then rotate by psi.
 psi_x = peptide[i].main_chain[3];
 n_in = peptide[i].main_chain[4];
 rot_coord(&peptide[i].side_chain[n_in],peptide[i].side_chain[psi_x],psival);
 for(x=0;x<3;x++)
    rot_coord(&peptide[i].next_one[x],peptide[i].side_chain[psi_x],psival);
}

//This is the meat of the program. This needs to be absolutely perfect to get everything right.

void rotate_back(int i, int toggle){
 int x,y,z;
 int phi_x,psi_x, n_in,ca_in,ha_in;
 struct Atom vec[5],prev,curr,trans,rot_axis;
 double ang;
 
 // Now to rotate peptide back and translate it. So what we need to do is translate and rotate it to coincide with prev peptide.
 // 1) Save the Ca of previous next_one as the center.
 // 2) Take cross product of Ca-N and N-HN vectors of both prev and curr. Get angle between them. Rotate taking the cross product as the rotation axis.
 n_in  = peptide[i].main_chain[1];
 ca_in = peptide[i].main_chain[2];
 ha_in = peptide[i].main_chain[0];
 
 trans.x = peptide[i-1].next_one[0].x;trans.y = peptide[i-1].next_one[0].y;trans.z = peptide[i-1].next_one[0].z;
 for(x=0;x<3;x++){
    peptide[i-1].next_one[x].x = peptide[i-1].next_one[x].x - trans.x;
    peptide[i-1].next_one[x].y = peptide[i-1].next_one[x].y - trans.y;
    peptide[i-1].next_one[x].z = peptide[i-1].next_one[x].z - trans.z;
 }
 //printf("Beginning of rotate back (%d %d %d) %f %f %f prev was %f %f %f\n",n_in,ca_in,ha_in,peptide[i].side_chain[n_in].x,peptide[i].side_chain[n_in].y,peptide[i].side_chain[n_in].z,peptide[i-1].next_one[1].x,peptide[i-1].next_one[1].y,peptide[i-1].next_one[1].z);


 vec[0].x = peptide[i-1].next_one[2].x - peptide[i-1].next_one[1].x;
 vec[0].y = peptide[i-1].next_one[2].y - peptide[i-1].next_one[1].y;
 vec[0].z = peptide[i-1].next_one[2].z - peptide[i-1].next_one[1].z;

 vec[1].x = peptide[i-1].next_one[1].x - peptide[i-1].next_one[0].x;
 vec[1].y = peptide[i-1].next_one[1].y - peptide[i-1].next_one[0].y;
 vec[1].z = peptide[i-1].next_one[1].z - peptide[i-1].next_one[0].z;
 cross_product(&prev,vec[0],vec[1]);

 vec[0].x = peptide[i].side_chain[ha_in].x - peptide[i].side_chain[n_in].x;
 vec[0].y = peptide[i].side_chain[ha_in].y - peptide[i].side_chain[n_in].y;
 vec[0].z = peptide[i].side_chain[ha_in].z - peptide[i].side_chain[n_in].z;

 vec[1].x = peptide[i].side_chain[n_in].x - peptide[i].side_chain[ca_in].x;
 vec[1].y = peptide[i].side_chain[n_in].y - peptide[i].side_chain[ca_in].y;
 vec[1].z = peptide[i].side_chain[n_in].z - peptide[i].side_chain[ca_in].z; 
 cross_product(&curr,vec[0],vec[1]);

 cross_product(&rot_axis,curr,prev);
 ang = angle_bet_vectors(curr,prev);
 
 for(x=0;x<peptide[i].num_side;x++)
    rot_coord(&peptide[i].side_chain[x],rot_axis,ang);
 for(x=0;x<3;x++)
    rot_coord(&peptide[i].next_one[x],rot_axis,ang);
 // We now have the two things in the same plane. Now have to rotate the Ns to coincide and then translate.

 vec[0].x = peptide[i-1].next_one[1].x - peptide[i-1].next_one[0].x;
 vec[0].y = peptide[i-1].next_one[1].y - peptide[i-1].next_one[0].y;
 vec[0].z = peptide[i-1].next_one[1].z - peptide[i-1].next_one[0].z;

 vec[2].x = peptide[i].side_chain[n_in].x - peptide[i].side_chain[ca_in].x;
 vec[2].y = peptide[i].side_chain[n_in].y - peptide[i].side_chain[ca_in].y;
 vec[2].z = peptide[i].side_chain[n_in].z - peptide[i].side_chain[ca_in].z;

 ang = 1.0*angle_bet_vectors(vec[2],vec[0]);
 cross_product(&rot_axis,vec[2],vec[0]); 
 
 for(x=0;x<peptide[i].num_side;x++)
    rot_coord(&peptide[i].side_chain[x],rot_axis,ang);
 for(x=0;x<3;x++)
    rot_coord(&peptide[i].next_one[x],rot_axis,ang);
 //printf("Coincide stage %f %f %f prev was %f %f %f\n",peptide[i].side_chain[n_in].x,peptide[i].side_chain[n_in].y,peptide[i].side_chain[n_in].z,peptide[i-1].next_one[1].x,peptide[i-1].next_one[1].y,peptide[i-1].next_one[1].z);
  
 for(x=0;x<peptide[i].num_side;x++){
    peptide[i].side_chain[x].x = peptide[i].side_chain[x].x + trans.x;
    peptide[i].side_chain[x].y = peptide[i].side_chain[x].y + trans.y;
    peptide[i].side_chain[x].z = peptide[i].side_chain[x].z + trans.z;
 }
 for(x=0;x<3;x++){
    peptide[i].next_one[x].x = peptide[i].next_one[x].x + trans.x;
    peptide[i].next_one[x].y = peptide[i].next_one[x].y + trans.y;
    peptide[i].next_one[x].z = peptide[i].next_one[x].z + trans.z;
    if(i > 1 && toggle == 1){
        peptide[i-1].next_one[x].x = peptide[i-1].next_one[x].x + trans.x;
        peptide[i-1].next_one[x].y = peptide[i-1].next_one[x].y + trans.y;
        peptide[i-1].next_one[x].z = peptide[i-1].next_one[x].z + trans.z;
    }
 }
 //printf("Translate of rotate back (%d) %f %f %f prev was %f %f %f\n\n\n",i,peptide[i].side_chain[n_in].x,peptide[i].side_chain[n_in].y,peptide[i].side_chain[n_in].z,peptide[i-1].next_one[1].x,peptide[i-1].next_one[1].y,peptide[i-1].next_one[1].z);
 
}

void get_neigh_list(int max, int curr){
 int x,y,z,a,b,c,i,j;
 double dist;
 
 x=curr;
    for(y=0;y<max;y++){
        if(y > x+1 || y < x-1){
            a=peptide[x].main_chain[2];
            b=peptide[y].main_chain[2];
            dist = get_distance(peptide[x].side_chain[a],peptide[y].side_chain[b]);
            if(dist < 7.0){
                c=peptide[x].neigh_list[0];
                peptide[x].neigh_list[c] = y;
                peptide[x].neigh_list[0]=c+1;
            }
        }
    }
}

double get_single_energy(int max, int curr){
 int x,y,z,a,b,c,i,j,p,q;
 double dist,ener, vdw, elec,diel;
 
 diel = 20.0;ener=0.0;vdw=0.0;elec=0.0; 
 x=curr;
     for(z=1;z<peptide[x].neigh_list[0];z++){
        y=peptide[x].neigh_list[z];
        for(a=0;a<peptide[x].num_side;a++){
            i=peptide[x].side_chain[a].ek;
            for(b=0;b<peptide[y].num_side;b++){
                j=peptide[y].side_chain[b].ek;
                dist = get_distance(peptide[x].side_chain[a],peptide[y].side_chain[b])+0.2;
                vdw = vdw + (4.0*epsilon[i][j]*(pow(sigma[i][j]/dist,12) - pow(sigma[i][j]/dist,6)));
                elec = elec + (138.9 *((peptide[x].side_chain[a].charge * peptide[y].side_chain[b].charge)/(dist*diel)));
            }
        }
    }

 ener=vdw+elec;
 return ener;
}


double get_energy(int max, int curr){
 int x,y,z,a,b,c,i,j,p,q;
 double dist,ener, vdw, elec,diel;
 
 diel = 20.0;ener=0.0;vdw=0.0;elec=0.0; 
 for(x=0;x<max;x++){
     for(z=1;z<peptide[x].neigh_list[0];z++){
        y=peptide[x].neigh_list[z];
        for(p=0;p<5;p++){
            a=peptide[x].main_chain[p];
            i=peptide[x].side_chain[a].ek;
            for(q=0;q<5;q++){
                b=peptide[y].main_chain[q];
                j=peptide[y].side_chain[b].ek;
                dist = get_distance(peptide[x].side_chain[a],peptide[y].side_chain[b]);
                vdw = vdw + (4.0*epsilon[i][j]*(pow(sigma[i][j]/dist,12) - pow(sigma[i][j]/dist,6)));
                elec = elec + (138.9 *((peptide[x].side_chain[a].charge * peptide[y].side_chain[b].charge)/(dist*diel)));
            }
        }
    }
 }

 ener=vdw+elec;
 return ener;
}

void copy_rotamer_lite(int x, int resn, int z, int toggle){
 int i;
    peptide[x].num_side = amino_database[resn][z].num_side;
    strcpy(peptide[x].name,amino_acids[resn]);
    peptide[x].ac_num = x+1;
    for(i=0;i<amino_database[resn][z].num_side;i++){
        peptide[x].side_chain[i].charge = amino_database[resn][z].side_chain[i].charge;
        peptide[x].side_chain[i].ek = amino_database[resn][z].side_chain[i].ek;
        peptide[x].side_chain[i].chi = amino_database[resn][z].side_chain[i].chi;
        peptide[x].side_chain[i].vdw = amino_database[resn][z].side_chain[i].vdw;
        peptide[x].side_chain[i].typ = amino_database[resn][z].side_chain[i].typ;
        strcpy(peptide[x].side_chain[i].name,amino_database[resn][z].side_chain[i].name);
        if(strcmp(amino_database[resn][z].side_chain[i].name,"N") == 0){
            peptide[x].main_chain[1] = i;
        }
        if(strcmp(amino_database[resn][z].side_chain[i].name,"CA") == 0){
            peptide[x].main_chain[2] = i;
        }
        if(strcmp(amino_database[resn][z].side_chain[i].name,"C") == 0){
            peptide[x].main_chain[3] = i;
        }
        if(strcmp(amino_database[resn][z].side_chain[i].name,"O") == 0){
            peptide[x].main_chain[4] = i;
        }
        if(strcmp(amino_database[resn][z].side_chain[i].name,"HN") == 0){
            peptide[x].main_chain[0] = i;
        }
        if(strcmp(amino_database[resn][z].side_chain[i].name,"HA") == 0){
            peptide[x].main_chain[5] = i;
        }
    }
    peptide[x].curr_rot = z;
}

void copy_rotamer(int x, int resn, int z, int toggle){
 int i;
    peptide[x].num_side = amino_database[resn][z].num_side;
    strcpy(peptide[x].name,amino_acids[resn]);
    peptide[x].ac_num = x+1;
    for(i=0;i<amino_database[resn][z].num_side;i++){
        peptide[x].side_chain[i].x = amino_database[resn][z].side_chain[i].x;
        peptide[x].side_chain[i].y = amino_database[resn][z].side_chain[i].y;
        peptide[x].side_chain[i].z = amino_database[resn][z].side_chain[i].z;
        peptide[x].side_chain[i].charge = amino_database[resn][z].side_chain[i].charge;
        peptide[x].side_chain[i].ek = amino_database[resn][z].side_chain[i].ek;
        peptide[x].side_chain[i].chi = amino_database[resn][z].side_chain[i].chi;
        peptide[x].side_chain[i].vdw = amino_database[resn][z].side_chain[i].vdw;
        peptide[x].side_chain[i].typ = amino_database[resn][z].side_chain[i].typ;
        strcpy(peptide[x].side_chain[i].name,amino_database[resn][z].side_chain[i].name);
        if(strcmp(amino_database[resn][z].side_chain[i].name,"N") == 0){
            peptide[x].main_chain[1] = i;
        }
        if(strcmp(amino_database[resn][z].side_chain[i].name,"CA") == 0){
            peptide[x].main_chain[2] = i;
        }
        if(strcmp(amino_database[resn][z].side_chain[i].name,"C") == 0){
            peptide[x].main_chain[3] = i;
        }
        if(strcmp(amino_database[resn][z].side_chain[i].name,"O") == 0){
            peptide[x].main_chain[4] = i;
        }
        if(strcmp(amino_database[resn][z].side_chain[i].name,"HN") == 0){
            peptide[x].main_chain[0] = i;
        }
        if(strcmp(amino_database[resn][z].side_chain[i].name,"HA") == 0){
            peptide[x].main_chain[5] = i;
        }
        if(toggle == 1){
            peptide[x].next_one[0].x = 0.046;peptide[x].next_one[0].y = 3.804;peptide[x].next_one[0].z = 0.000; // This is the CA atom
            peptide[x].next_one[1].x =-0.348;peptide[x].next_one[1].y = 2.400;peptide[x].next_one[1].z = 0.000; // This is the N atom
            peptide[x].next_one[2].x =-1.328;peptide[x].next_one[2].y =2.166;peptide[x].next_one[2].z = 0.000; // This is the NH atom
        }
    }
    peptide[x].curr_rot = z;
}

void copy_params(struct Amino *prot, char *pdbline, int pos){
 int x,y,z;
 float tmp_x,tmp_y,tmp_z;
 char temp[100];

 x=prot->num_side;
 copy_substr(pdbline,temp,30,39);
 prot->side_chain[x].x = atof(temp);
 copy_substr(pdbline,temp,38,47);
 prot->side_chain[x].y = atof(temp);
 copy_substr(pdbline,temp,46,55);
 prot->side_chain[x].z = atof(temp);

 copy_substr(pdbline,temp,12,16);
 strcpy(prot->side_chain[x].name,temp);
 if(strcmp(temp," CA ") == 0){
    prot->main_chain[2] = prot->num_side;
 }
 else if(strcmp(temp," N  ") == 0){
    prot->main_chain[1] = prot->num_side;
 }
 else if(strcmp(temp," C  ") == 0){
    prot->main_chain[3] = prot->num_side;
 }
 else if(strcmp(temp," H  ") == 0){
    prot->main_chain[0] = prot->num_side;
 }
 else if(strcmp(temp," HA ") == 0){
    prot->main_chain[5] = prot->num_side;
 }
 else if(strcmp(temp," O  ") == 0){
    prot->main_chain[4] = prot->num_side;
 }
 copy_substr(pdbline,temp,54,63);
 prot->side_chain[x].charge = atof(temp);
 copy_substr(pdbline,temp,62,69);
 prot->side_chain[x].vdw = atof(temp);
 //fprintf(stderr,"%c\n",pdbline[77]);
 if(pdbline[77] == 'C'){
    prot->side_chain[x].typ = 0;
 }
 else if(pdbline[77] == 'O'){
    prot->side_chain[x].typ = 1;
 }
 else if(pdbline[77] == 'N'){
    prot->side_chain[x].typ = 2;
 }
 else if(pdbline[77] == 'H'){
    prot->side_chain[x].typ = 3;
 }
 else{
    prot->side_chain[x].typ = 4;
 }
    

 prot->num_side++;
}

int rama_shortest_distance(int pep1, int max2, char *var){
 int ans,x,y,z,a,b;

 ans = 0;
 if(strcmp(var,"frame") == 0){
    for(x=0;x<peptide[pep1].num_side;x++){
        a=peptide[pep1].side_chain[x].typ;
        for(z=0;z<max2;z++){
            for(y=0;y<framepept[z].num_side;y++){
                b=framepept[z].side_chain[y].typ;
                if(get_distance(peptide[pep1].side_chain[x],framepept[z].side_chain[y]) < rama_limits[a][b]){
                    ans = -1;
                    return ans;
                }
            }
        }
    }
 }
 else if(strcmp(var,"peptide") == 0){
    for(x=0;x<peptide[pep1].num_side;x++){
        a=peptide[pep1].side_chain[x].typ;
        for(z=0;z<max2;z++){
            for(y=0;y<smallpept[z].num_side;y++){
                b=smallpept[z].side_chain[y].typ;
                if(get_distance(peptide[pep1].side_chain[x],smallpept[z].side_chain[y]) < rama_limits[a][b]){
                    ans = -1;
                    return ans;
                }
            }
        }
    }
 }
 else{
    for(x=0;x<peptide[pep1].num_side;x++){
        a=peptide[pep1].side_chain[x].typ;
        for(z=0;z<=max2;z++){
            if(z-pep1 > 1){
                for(y=0;y<peptide[z].num_side;y++){
                    b=peptide[z].side_chain[y].typ;
                    if(get_distance(peptide[pep1].side_chain[x],peptide[z].side_chain[y]) < rama_limits[a][b]){
                        //fprintf(stderr,"Comp [%s](%d)\t[%s](%d)\n",peptide[pep1].side_chain[x].name,pep1,peptide[z].side_chain[y].name,z);
                        ans = -1;
                        return ans;
                    }
                }
            }
            else if(pep1 == z-1){
                for(y=0;y<peptide[z].num_side;y++){
                    b=peptide[z].side_chain[y].typ;
                    if(strcmp(peptide[pep1].side_chain[x].name,"CA")== 0){
                        if(strcmp(peptide[z].side_chain[y].name, "N") != 0) {
                            if(get_distance(peptide[pep1].side_chain[x],peptide[z].side_chain[y]) < rama_limits[a][b]){
                                //fprintf(stderr,"%s(%d)\t%s(%d)\n",peptide[pep1].side_chain[x].name,pep1,peptide[z].side_chain[y].name,z);
                                ans = -1;
                                return ans;
                            }
                        }
                    }
                    else if(strcmp(peptide[pep1].side_chain[x].name,"C")== 0){
                        if(strcmp(peptide[z].side_chain[y].name, "N") != 0 && strcmp(peptide[z].side_chain[y].name, "HN") != 0 && strcmp(peptide[z].side_chain[y].name, "CA") != 0){
                            if(get_distance(peptide[pep1].side_chain[x],peptide[z].side_chain[y]) < rama_limits[a][b]){
                                //fprintf(stderr,"%s(%d)\t%s(%d)\n",peptide[pep1].side_chain[x].name,pep1,peptide[z].side_chain[y].name,z);
                                ans = -1;
                                return ans;
                            }
                        }
                    }
                    else if(strcmp(peptide[pep1].side_chain[x].name,"O")== 0){
                        if(strcmp(peptide[z].side_chain[y].name, "N") != 0){
                            if(get_distance(peptide[pep1].side_chain[x],peptide[z].side_chain[y]) < rama_limits[a][b]){
                                //fprintf(stderr,"[%s](%d)\t[%s](%d)\n",peptide[pep1].side_chain[x].name,pep1,peptide[z].side_chain[y].name,z);
                                ans = -1;
                                return ans;
                            }
                        }
                    }
                    else{
                            if(get_distance(peptide[pep1].side_chain[x],peptide[z].side_chain[y]) < rama_limits[a][b]){
                                //fprintf(stderr,"[%s](%d)\t[%s](%d)\n",peptide[pep1].side_chain[x].name,pep1,peptide[z].side_chain[y].name,z);
                                ans = -1;
                                return ans;
                            }
                    }
                    
                }
            }    
        }
    }
 }
    
 return ans;
}
        

/* This is the beginning of the program. As of now, everything is in one file to keep things simple for backing up. Later on, we can add each of the functions etc in a separate file and maybe add some speedups etc along the way. */

int main(int argc, char **argv){
 FILE *inp, *outf, *all_fil, *dis_fil, *tail_fil;
 int a,b,c,d,x,y,z,at_index,len,res_index,i,iter,model,do_back_step, search_rotamer,opt_backbone,rotamer_state[MAXLEN],tail_backbone,siz,randf,real_allowed;
 char inpfilnam[100],line[500],tmp[100],at_name[100],sequence[MAXLEN],ch,sec,outfilnam[100];
 char seq_markup[MAXLEN],temp[500];
 double tmp_phi,tmp_psi,tmp_x,tmp_y,tmp_z,tmp_chg,tmp_rad,phi,psi,energy,tmpenergy;
 struct Atom dihed[4];
 struct timeval tv;
 struct tm *tm;
 double *phivals,*psivals;
 double step_phi[10][5][2];
 int loops[MAXLEN],loop_num,namino,curr,prev,namino1;
 double testphi[100],testpsi[100],allowed,totmeso,tail_allowed,num_trial;


 amino_database = (struct Amino**) calloc(30,sizeof(struct Amino*));
 for(x=0;x<30;x++)
    amino_database[x] = calloc(30,sizeof(struct Amino));

 for(x=0;x<30;x++){
    for(y=0;y<30;y++)
        amino_database[x][y].num_side = 0;
 }

 // 05-18-2014. Among the things to do is make rotation groups. We can add the group number in the final_rot.dat. When tweaking the rotamers, we can then rotate according to chi0, chi1 etc groups.
 inp = fopen("chi3.txt","r");
 while((fgets(line,999,inp))!=NULL){
    if(strstr(line,"//")==NULL){
        sscanf(line,"%s %d %s %lf %lf %lf %lf %lf %d %d",tmp,&at_index,at_name,&tmp_x,&tmp_y,&tmp_z,&tmp_chg,&tmp_rad,&z, &c);
        x=get_amino3_index(tmp);
        y = amino_database[x][at_index-1].num_side;
        amino_database[x][at_index - 1].side_chain[y].x = tmp_x;
        amino_database[x][at_index - 1].side_chain[y].y = tmp_y;
        amino_database[x][at_index - 1].side_chain[y].z = tmp_z;
        amino_database[x][at_index - 1].side_chain[y].charge = tmp_chg;
        amino_database[x][at_index - 1].side_chain[y].vdw = tmp_rad;
        amino_database[x][at_index - 1].side_chain[y].ek = z;
        amino_database[x][at_index - 1].side_chain[y].chi = c;
        if(at_name[0] == 'C'){
            amino_database[x][at_index - 1].side_chain[y].typ = 0;
        }
        else if(at_name[0] == 'O'){
            amino_database[x][at_index - 1].side_chain[y].typ = 1;
        }
        else if(at_name[0] == 'N'){
            amino_database[x][at_index - 1].side_chain[y].typ = 2;
        }
        else if(at_name[0] == 'H'){
            amino_database[x][at_index - 1].side_chain[y].typ = 3;
        }
        else{
            amino_database[x][at_index - 1].side_chain[y].typ = 4;
        }
            
            
        strcpy(amino_database[x][at_index - 1].side_chain[y].name,at_name);
        amino_database[x][at_index-1].num_side++;
        //printf("Amino acid (%s) = %d\n",tmp,c);
    }
 }
 fclose(inp);
 // We have the entire side_chain rotations in the database now. The maximum number of rotamers is also known. Now, we just have to choose a rotamer (weights of rotamers given in another array not implemented yet. As of now, all rotamers are equally likely. Now, on to building the protein backbone with the side chain atoms.
 //
 //for(x=0;x<30;x++)
 //   printf("%s %d\n",amino_acids[x],amino_database[x][0].num_side);

 len=MAXLEN;
 peptide = (struct Amino*) calloc(len+10, sizeof(struct Amino));
 tmppept = (struct Amino*) calloc(len+10, sizeof(struct Amino));
 framepept = (struct Amino*) calloc(len+10, sizeof(struct Amino));
 smallpept = (struct Amino*) calloc(len+10, sizeof(struct Amino));

 phivals = calloc(len+10,sizeof(double));
 psivals = calloc(len+10,sizeof(double));

 inp = fopen(argv[1],"r");x=0;z=0;
 while(fgets(line,999,inp)!=NULL){
    if(line[0] != '#'){
        sscanf(line,"%c %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %c",&ch,&phivals[x],&psivals[x],&ncac_angles[x][1],&ncac_angles[x][0],&ncac_angles[x][2],&ncac_angles[x][3],&ncac_angles[x][4],&ncac_angles[x][5],&ncac_angles[x][6],&ncac_angles[x][7],&ncac_angles[x][8],&sec);
        if(strchr("HBEGI",sec) ==NULL){
            loops[z]=x;
            z++;
        }
        sequence[x]=ch;
        for(y=0;y<8;y++)
            calc_angles[x][y] = ncac_angles[x][y];
        x++;
    }
 }
 sequence[x]='\0';
 fclose(inp);
 len = strlen(sequence);
 loop_num = x;
 /*if(y == -1){
    fprintf(stderr,"Simulating Std sequence with length = %d\n\t\"%s\"\n",strlen(sequence),sequence);
 }
 else{
    fprintf(stderr,"Simulating NonStd sequence (NonStd char ignored) with length = %d\n\t\"%s\"\n",strlen(sequence),sequence);
 }*/

 inp=fopen(argv[2],"r");namino=-1;prev=-100;
 while((fgets(line,999,inp))!=NULL){
    if(strstr(line,"ATOM") == line){
        // If the residue number is equal to ac_resno, then copy the current index into resno.
        copy_substr(line,temp,22,26);
        curr = atoi(temp);
        if(curr != prev){
            namino++;
            prev = curr;
            framepept[namino].ac_num = curr;
            framepept[namino].chain = line[21];
            framepept[namino].num_side = 0;
            copy_substr(line,temp,17,20);
            strcpy(framepept[namino].name,temp);
        }
        copy_params(&framepept[namino],line,namino);
    }
 }
 fclose(inp);

 inp=fopen(argv[3],"r");namino1=-1;prev=-100;
 while((fgets(line,999,inp))!=NULL){
    if(strstr(line,"ATOM") == line){
        // If the residue number is equal to ac_resno, then copy the current index into resno.
        copy_substr(line,temp,22,26);
        curr = atoi(temp);
        if(curr != prev){
            namino1++;
            prev = curr;
            smallpept[namino1].ac_num = curr;
            smallpept[namino1].chain = line[21];
            smallpept[namino1].num_side = 0;
            copy_substr(line,temp,17,20);
            strcpy(smallpept[namino1].name,temp);
        }
        copy_params(&smallpept[namino1],line,namino1);
    }
 }
 fclose(inp);
 
 /* **********************************************************************************
 * Steps in the algorithm for getting the conformation from phi/psi values.
 * 1) Get the vector that will align the master[0] to residue[x]. Copy master[0] and master[1] to tmp and rotate them.
 * 2) Now align residue[x+1] with master[1].
 * 3) Rotate peptide bond with phi and psi using the peptide coordinates.
 * 4) Go back to 1 with the next residue.
 *
 * Question is not whether we can get the conformation. The real question is how to accomodate the non-ideal bond lengths and bond angles. One way is to transform them before the rotations. That might require some thinking. Or a Z matrix method might be a good idea too. Would require doing away with most of the code we have right now, so on the backburner right now.
 * Solved the problem without Z-matrices. We can rotate and translate parts of the peptide. That way the next_ones get rotated translated giving rise to modified conformation without modifying the entire protein. It required local perturbations, and right now everything works fine.
 */
 
 /* *********************************************************************************
  */
 model=1;
 srandom(time(NULL));
 //fprintf(stderr,"%d %d\n",len,strlen(sequence));
 gettimeofday(&tv, NULL);
 tm=localtime(&tv.tv_sec);
 srandom(tv.tv_usec);
 // The loop where we take the input file and build an initial model out of it.
 x=0;
 while(x<len){
    res_index = get_amino1_index(sequence[x]);
    z=(random()%max_side[res_index]);
    copy_rotamer(x,res_index,z,1);
    rotamer_state[x] = z;
    x++;
 }
 for(x=0;x<len;x++){
    make_non_ideal(x);
    rotate_torsion(phivals[x],psivals[x],x);
    if(x>0){
        rotate_back(x,1);
    }
 }
 //print_peptide(0,len,model);model++;
 energy=0.0;
 for(x=0;x<len;x++){
    peptide[x].neigh_list[0] = 1;
    get_neigh_list(len,x);
 }
 for(x=0;x<len;x++){
    peptide[x].curr_ener = get_single_energy(len,x);
    energy = energy + peptide[x].curr_ener;
 }
 //fprintf(stderr,"Start point energy is : %f with %d residues in loops\n",energy,loop_num);
 // The above output is only for debug purposes. Later on, we will output only after evey 1000 iterations or something like that.
 //
  
 //all_fil=fopen("10-mer/surf_allowed_4.pdb","w");
 //dis_fil=fopen("10-mer/surf_disallowed_4.pdb","w");
 //tail_fil=fopen("10-mer/tail_allowed_4.pdb","w");
 iter=0;
 allowed = 0.0;
 totmeso = 0.0;
 tail_allowed = 0.0;
 num_trial = 0.0;

 fprintf(stdout,"(1) No clash\t(2) No surface clash\t(3) Self-avoiding conformations\tRatio (1)/(3)\tRatio (2)/(3)\tTotal number of trails\n");

 siz = *(&checkphivals + 1) - checkphivals;

 iter = 0;
 while(iter < 100000){
    for(x=0;x<len-225;x++){
        if (randoms(&randf,0, siz)){
            testphi[x] = checkphivals[randf];
            testpsi[x] = checkpsivals[randf];
        } 
    }
    opt_backbone = 0;
    tail_backbone = 0;
    real_allowed = 0;
    z=226;
    for(x=z-1;x<len;x++){
        res_index = get_amino1_index(sequence[x]);
        copy_rotamer(x,res_index,rotamer_state[x],1);
        phivals[x] = testphi[x-z+1];
        psivals[x] = testpsi[x-z+1];
        rotate_torsion(phivals[x],psivals[x],x);
        if(x>0){
            rotate_back(x,1);
        }
    }
    for(x=z;x<len;x++){
        if(rama_shortest_distance(x+1,namino,"frame") == -1){
            opt_backbone = 1;
        }
        if(rama_shortest_distance(x+1,namino1,"peptide") == -1){
            tail_backbone = 1;
        }
        if(rama_shortest_distance(x,len,"self") == -1){
            real_allowed = 1;
        }
    }
    if(real_allowed == 0){
        if(opt_backbone == 0){
            allowed = allowed + 1.0;
        }
        if(opt_backbone == 0 && tail_backbone == 0){
            tail_allowed = tail_allowed + 1.0;
        }
        totmeso = totmeso + 1.0;
    }
    //else{
    //        print_peptide_file(226,len+1,model,outf);model++;
    //}
        
    iter=iter+1;
    if(iter%1000 == 0){
        fprintf(stdout,"%.0f\t%.0f\t%.0f\t\t%.4f\t%.4f\t%.0f\n",tail_allowed,allowed,totmeso,tail_allowed/totmeso,allowed/totmeso,num_trial);
        iter = 0;
    }
    /*if(iter%5 == 0){
        if(real_allowed == 0){
        //print_peptide(226,len+1,model);model++;
        if(opt_backbone == 0 && tail_backbone == 0){
            print_peptide_file(226,len+1,model,tail_fil);model++;
        }
        if(opt_backbone == 0 && tail_backbone != 0){
            print_peptide_file(226,len+1,model,all_fil);model++;
        }
        if(opt_backbone != 0 && tail_backbone != 0){
            print_peptide_file(226,len+1,model,dis_fil);model++;
        }
        if(opt_backbone != 0 && tail_backbone == 0){
            print_peptide_file(226,len+1,model,dis_fil);model++;
        }
        if(model == 25000){
            exit(-1);
        }
        }
    }*/
    num_trial = num_trial + 1.0;
    
 }                               
 //fclose(tail_fil);
 //fclose(dis_fil);
 //fclose(all_fil);
 return 0;
} 
